#################################
## Basically for our components
#################################

Welcome..

At the end of the last lesson we discussed the importance of incorporating accessibility into your first round of developement. I cannot stress enough: Accessibility is not a secondary task that you come back to after your app is working. It is a primary concern that needs to be addressed as part of your development process.

In this course I decided to keep it separate for educational reasons, introducing one concept at a time and building upon those concepts incrementally. We now have the conceptual groundwork laid out to add in our accessibility features. 

We will go over what I consider some of the very basic accessibility concepts that you need to keep fresh in mind when developing forms. These concepts are not technically Vue-specific, but we will learn how to apply them in the context of our view form components.

Lets dive right in.

########################
### Appropriate Types
########################

In HTML we have a wide variety of input elements to craft our forms, but one element in particular rules them all. The catch-all input allows us the flexibility of creating text inputs, but we can also transform it into checkboxes and radio buttons with the type property. 


A common mistake is to ignore this type property when creating text inputs. Most of us know and commonly use two regularly:
* email
* password

When using a specific type in an input element, not only we get better autocompletion for our form, but it also allows screen readers to better understand what type of data we want to retreive from the user. A type of tel for example, will provide a user on the mobile phone with a handly numeric keyboard with phone symbols like + * #.

Your users with mobility problems will definitely be grateful for this one!

Bottom line: Don't forget to set your type, even when the input is not of type password or email.

Here is a list of the available types for an input element:

* button
* checkbox
* color
* date
* datetime-local
* email
* file
* hidden
* image
* month
* number
* password
* radio
* range
* reset
* search
* submit
* tel
* text
* time
* url
* week



#############################
## Use Fieldset and Legend
#############################

Two often overlooked or under-taught elements in HTMl are fieldset and legend.

In forms, usually we group our inputs logically. For example, you would usually code your forms to first ask the user for their personal data like:
* Name
* Last Name
* Phone

Later on, another section may ask them for a shipping address.

For accessible users, this information may not be as immediately available without having to tab through the whole form. This is where <fieldset> and <legend> comes to play.

You should always try to wrap up sections of your form inside a fieldset element. This will logically group the inputs inside of it. Then, the first element of a fieldset will be a legend element which will provide a Title for that particular fieldset.

If for some reason, you don't want the legend to show on your form (usually because of design reasons), you can always position it absolutely, outside of the visible screen. 

For our current form in SimpleForm.vue, we can wrap up our logical sections inside fieldset like in the following example:


#### SimpleForm.vue  -- begin
<template>
  <div>
     <h1>Create an event</h1>
     
     <form @submit.prevent="sendForm">
     
     <BaseSelect
        :options="categories"
        v-model="event.category"
        label="Select a Category"
     />
     
     <fieldset>
     <legend> Where is your event? </legend>
     <BaseInput
       v-model="event.title"
       label="Title"
       type="text"
     />
     
     <BaseInput
       v-model="event.description"
       label="Title"
       type="text"
     />
     
     <BaseInput
        v-model="event.description"
        label="Description"
        type="text"
     />
     
     </fieldset>     
     
     <fieldset>
        <legend>Pets</legend>
        <p>Are pets allowed?</p>
        
        <div>
          <BaseRadioGroup
             v-model="event.pets"
             name="pets"
             :options="petOptions"
          />
        </div>
     </fieldset>
     
     <fieldset>
       <legend>Extras</legend>
       <div>
         <BaseCheckbox
            v-model="event.extas.music"
            label="Live Music"
         />
       </div>
     </fieldset>
     
     <button type="submit">Submit</button>
     
     </form>
     
     <pre>{{event}}</pre>
  </div>
</template>
#### SimpleForm.vue  -- end

We can add the style tag to remove the default borders and margins, and to style the legend tags as we had the headers before.


#### SimpleForm.vue  -- begin
<style>
fieldset{
  border:0;
  margin:0;
  padding:0;
  
}

legend{

 font-size: 28px;
 font-weight: 700;
 margin-top: 20px;

}

</style>

#### SimpleForm.vue  -- end


I'm going to use Firefox this time as it has a very nice accessibility inspector tool.

Check the accesssibility tab, you can see how now the logical grouping of our form will be.

##############################################
## DO NOT RELY ON PLACEHOLDERS
##############################################

A popular design pattern that emerged a few years ago used the placeholder attribute of inputs to describe the type of content that the element was expecting.Sadly this is still sometimes used now-a-days instead of a proper label.

Placeholders should only be used to describe the intended value, but not as a replacement for a descriptive label. Placeholders disappear whenever a user starts typing into the field, forcing the user to keep in mind what the field was expecting. Aditionally, some users can have problems differentiating between a field with a placeholder and a field that has pre-populated or filled content. 

As far as screen readers go, each screen reader may treat the placehoder attribute differently, but as long as correctly set label is in place, it should not be much of a concern to leave it in.



#########
## Labels
#########

Speaking about labels, let us talk about a really powerful accessibility feature that is sadly, very commonly underused, or misused in forms.

If we navigate to firefox again in the accessibility tab and inspect our Title input, we can see a <warning> icon right next to it. This means we have a problem.

Let us take a look at the information panel. The checks section is already telling us the issue: "Form elements should have a visible text label."

This may come as a surprise, since our Title field clearly has a label on top of it describing what we intend for this input.

Title:
  #####
  
  
For our sighted users, however, this is not evident. We have not yet linked these two HTML elements together, and that is an assumption that a screen reader cannot afford to make. Thankfully, this is a very easy fix!

There are a few ways to link an input element with its label, the first one is to actually nest the input inside of the label element.

<label>
   <input/>
</label>


This is one of the easiest ways to make sure that your input is always correctly linked to the related label, but, i want to go into depthinto the second and usually more "common" way to relate HTML elements because it's going to come in handy later when we look at error messages. This method involves using IDs.

Let's jump directly into our BaseInput component and figure out how to create a relationship between our <label> and <input> by using an ID.

You may be thinking that perhaps the most obvious option would be to add a property, so that the parent can determine the id of the element, and then we don't have to worry about it inside our compoenent. And you would be right... But what if there were a way we could dynamically generate unique number identifiers for every component in our form without having to resort to manual props?

We are going to create a Vue3 composable that allows us to create these dynamic unique identifiers, or UUIDs for short. I know this is bit of a jump from the pace of the course, but if you need a refresher on Vue 3 composition API or composables we have a course titled Build a Gmail clone with Vue 3 - here on Vue Mastery to get you up to speed. At any rate, don't worry too much, it's going to be a really simple one.

If you are following along with the repository files, I have gone ahead and created a UniqueID.js file inside the features folder. Let's take a look:

### UniqueID.js -- begin
let UUID = 0

export default function UniqueID(){
   const getID = () => {
      UUID++
      return UUID
   }
   
   return {
     getID
   }
}
### UniqueID.js -- end

First we declare a let variable with a default value of 0. This will increase as we create more and more components - the first component will have an id of 1, the second of 2, and so on.

We are going to export a function UniqueID, When executed, this function will return an object, which contains a function under the property getID. This function will increase by 1 the global UUID counter and return it.


Know also that there are a plenty of UUID libraries out there that you can use in this place of this custom solution, but I wanted to show you just how easy it can be.

Let's look at this in action to better understand it, by looking at BaseInput.vue.

First, we are going to import our new composable.

## BaseInput.vue -- begin
<script>
  import UniqueID from "../features/UniqueID";
  export default {...}
</script>

## BaseInput.vue -- end

Now that we have it ready, we can generate a new unique ID inside our component's setup method. Let's go ahead and do that.








